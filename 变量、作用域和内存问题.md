## 变量、作用域和内存问题

1、理解基本类型和引用类型的值
2、理解 执行环境
3、理解垃圾收集

按照 ECMA-262 的定义，javaScript 的变量与其他语言的变量有很大区别。jsvaScript 变量松散类型的本质，决定于它只是在特定时间用于保存特定值得一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值得规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度来看，这可能是一个既有趣又强大，同时又容易出问题的特性，但 javaScript 变量实际的复杂程度还远不止如此。

4.1 基本类型和引用类型的值
ECMAScript 变量可能包含两种不同数据类型的值：基本数据类型和引用数据类型的值。基本类型值得是简单的数据段，而引用数据类型指的是那些可能由多个值构成的对象。
在将一个值赋给一个变量时，解析器必须确定之歌值是基本类型值还是引用类型值。 基本数据类型是按值访问的，可以操作保存在变量中的实际的值。
引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 因此引用类型的值是按引用访问的。

     tip: 在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript放弃了在这一传统。

     4.1.1 动态的属性
      定义基本类型值和引用类型值得方式是类似的：创建一个变量并且为改变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。

    4.1.2 复制变量值
      除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。
      如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。  这两个变量可以参与任何操作而不会相互影响。
      当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

    4.1.3 传递参数
      ECMAScript中所有函数的参数都是按值传递的。也就是把函数外部的值渎职给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值得传递，则如同引用类型变量的复制一样。
      在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用ECMAScript的概念来说，就是arguments对象的一个元素)。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反应在函数的外部。
        function setName(obj){
          obj.name = "Nichilas"
        }
        var person = new Object();
        setName(person)
        alert(person.name) //"Nichilas" 影响了外部


        function setName(obj){
          obj.name = "Nichilas";
          obj = new Object();
          obj.name = "Greg"
        }
        var person = new Object();
        setName(person);
        alert(person.name) //"Nichilas"

        第二个例子在函数中 为obj重新定义了一个对象，另一个是为新对象定义了一个name属性与属性值。在把person 传递给setName()后，其name属性被设置为"Nichilas"。然后又将一个新的对象赋给变量obj,同时将其name属性设置为  "Greg"。如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为"Greg"的新对象。但是，当接下来再访问person.name时，显示的值仍然是"Nichilas"。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。

        tips:可以将ECMAScript函数的参数想象成局部变量。

        4.1.4  检测类型
        要检测一个变量是不是基本数据类型？ typeof 操作符是最佳工具。 具体说 typeof操作符是确定一个变量时字符串、数值、布尔值，还是undefined的最佳工具。如果变量时一个对象或null,则typeof操作符会像下面例子中所示的那样返回"object"

        虽然在检测基本数据类型时typeof是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值时对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了instanceof操作符
        如果变量时给定引用类型(根据它的原型链来识别)的实例，那么instanceof操作符就会返回true
        根据规定，所有引用类型都是Object的实例。因此，在检测一个引用类型值和object构造函数时，instanceof操作符始终会返回true。当然，如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false.因为基本类型不是对象。

        tips:使用typeof操作符检测函数时，该操作符会返回"function" 在safari 5及之前版本和chrome 7 及之前版本中使用typeof 检测正则表达式时，由于规范的原因，这个操作符也返回"function".由于上述浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用typeof会返回"function"。在IE和Firefox中，对正则表达式应用typeof会返回"object"。

        4.2 执行环境及作用域
            执行环境 有时也称为环境 是javascript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的 变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编程的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
            全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为windows对象的属性和方法创建的。某个执行环境中所有代码执行完毕后，该环境被销毁。保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退出————例如关闭网页或浏览器————时才会被销毁)。
               每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。
               当代码在一个环境中执行时，会创建 变量对象 的一个作用域链 scope chain。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象 activetion object 作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域中的最后一个对象。
                标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域的前端开始，然后逐级地向后回溯，直至找到标识符为止(如果找不到标识符，通常会导致错误发生)。

            内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性的、有次序的。每个人环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。 搜索顺序，现在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。  
            tips:函数参数也被当做变量来对象，因此其访问规则与执行环境中的其他变量相同。

            4.2.1 延长作用域链
              虽然执行环境的类型总共只有2种 ————全局和局部（函数），但还是有其他方法来延长作用域链。
            这么说是因为有些语句可以在作用域的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：
               1、try-catch语句的catch块；
               2、with语句；
               这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明

            4.2.2 没有块级作用域
                javaScript没有块级作用域。 在其他类C的语言中，由花括号封闭的代码块都有自己的作用域（如果用ECMAScript的话来讲，就是他们的执行环境），因而支持根据条件来定义变量。
                if(true){
                  var color = "bule"
                }
                alert(color) //"blue"
                在C、C++或java中，color会在if语句执行完毕后被销毁。但在javaScript中。if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。 在使用for语句时一定牢记这一差异。
              对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于javaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。
                  1、声明变量
                  使用var关键字声明的变量会自动添加到 最接近的 环境中，在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动添加到全局环境。
                  tips:在编写javaScript代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。

                  2、查询标识符
                  当在某个环境中为了读取或写入而引入一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程 从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到，搜索过程停止，变量就绪。如果局部环境中没有找到该变量名，则继续沿作用域链向上搜索。一直追溯到全局环境的变量对象。 如果没有找到，意味着该变量尚未声明
                  会报错

                  tips:变量查询也不是没有代价的。访问局部变量要比访问全局变量更快。但是 js引擎在优化标识符查询方面 很好，因此这个差别在将来恐怕就可以忽略不计


                  4.3 垃圾收集
                  javaScript 具有自动垃圾回收机制，也就是说执行环境会负责管理代码执行过程中使用的内存。而在C和c++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。在编写js程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾回收机制的实现原理很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾回收机制会按照固定的时间间隔(或代码执行中预定的收集时间)，周期性地执行这一操作。
                     函数中局部变量的正常生命周期




            
