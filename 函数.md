### Function 类型

函数实际上是对象， 每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也就是一个指向函数对象的指针，不会被某个函数绑定。
Function 是函数的构造器 f(){ [native code] } 是函数的构造原型 也就是构造器的 prototype

#### function 关键字声明定义 与表达式定义区别：

function 函数声明 具有函数声明提升 会提升到当前环境的顶部

#### Function 构造器 定义函数

函数是对象，函数名是指针 的概念的清晰理解。
var sum = new Function("num1","num2","return num1+num2"); 不推荐
技术角度讲是一个函数表达式，但是不推荐这种方法定义函数。因为这种语法会导致解析两次代码（第一次是解析常规的 ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。
函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。

#### 函数没有重载

ECMAScript 函数没有签名，不能做到重载，命名重复时后面会覆盖前面。
将函数名想象为指针，声明两个同名函数，后面函数覆盖前面的函数。
function 关键字冲突时，只保留最后一个函数名的引用的函数对象。
表达式 变量名冲突时，前面赋值，在未修改引用指针之前，是可以调用前面函数，后面函数赋值时，更改引用指针后，调用不到前面函数了

#### 作为值得函数

因为 ECMAScript 中的函数名本身就是白能量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个参数，而且可以将一个函数作为另一个函数的结果返回。

#### 函数内部的属性

在函数内部，有两个特殊的对象：arguments 和 this. arguments 对象是一个类数组对象，包含着传入函数的所有参数。可以使用方括号语法访问它的每一个元素，使用 length 属性来确定传递进来多少个参数。
arguments 对象的长度是由传入的参数个数决定，不是定义函数时的命名参数（形参）的个数决定的。
没有传递值得命名参数将被自动赋予 undefined 值。
ECMAScript 中的参数在内部是由一个数组来表示的。函数接收到的始终是这个数组，而不关心数组中包含哪些参数。

arguments 对象的主要用途是保存函数参数，但这个对象有一个名为 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。

#### callee 属性

返回正被执行的 Function 对象
实参：callee 属性是 arguments 对象的一个成员，返回拥有这个 arguments 对象的函数； 实现递归 可以继续调用
允许匿名函数称为递归。

快速模式运行时，arguments 对象不可用

#### this 对象

this 引用的是函数 据以执行的环境对象
this 与 caller 输出的都是函数执行依赖的环境 但是最外围环境 caller 输出的是 null
caller 属性 函数对象的 caller 属性 除了 opera 早期版本不支持 ，其他浏览器都支持这个属性；这个属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null

严格模式 arguments.callee 会错，arguments.caller 也会错误，非严格模式是 undefined 始终是 而且不能赋值

### 函数属性和方法

函数是对象，函数也有属性和方法。
每个函数包含两个属性：length 和 prototype.
其中，length 属性表示函数希望接收的命名参数的个数
prototype 是保存它们所有实例方法的真正所在。换句话说，诸如 toString()和 valueOf()等方法实际上都保存在 prototyoe 名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype 属性的作用是极为重要的
在 es5 中 prototype 属性是不可枚举的
每个函数都包含两个非继承而来的方法：apply()和 call().
这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体类的 this 对象的值。首先 apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中第二个参数可以是数组，也可以是 arguments 对象

函数中
function fn1(){
this.x =2;
var x = 3;
}
上面定义在 this 对象上的一个属性 当函数被调用 this 指针被更改时随着更改
函数中定义变量 是定义在 函数环境的变量对象上 只在此函数中访问

##### call()与 apply()区别

这两个方法的用用相同，都是在特定的作用域中调用函数，实际上等于设置函数体 this 对象的值 他们第一个参数都是 this,特定作用域

call()的其余参数都直接传递给函数 传递给函数的参数必须逐个列举出来。
apply()只接收两个参数 一个作用域 this 一个参数数组 ，也可以是 arguments 对象 如果传递 arguments 对象或者参数数组 使用 apply 更方便

它们的强大之处在于能够扩充函数赖以运行的作用域。
用 call() apply()扩充作用域的好处就是对象不需要与方法有任何耦合关系。

bind() 这个方法会创建一个函数的实例，其 this 值会被绑定到传给 bind()函数的值
